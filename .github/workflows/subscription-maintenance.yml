name: Subscription Maintenance
on:
  schedule:
    # Run subscription maintenance every 6 hours
    - cron: '0 */6 * * *'
  workflow_dispatch: # Allow manual triggers for testing

jobs:
  subscription-maintenance:
    name: Subscription Expiry & Maintenance
    runs-on: ubuntu-latest
    timeout-minutes: 5
    
    steps:
      - name: Subscription Maintenance
        run: |
          echo "üìÖ Starting subscription maintenance for CoinSpree..."
          
          # Make authenticated request to subscription maintenance endpoint
          echo "üîó Endpoint: ${{ secrets.VERCEL_DEPLOYMENT_URL }}/api/cron/subscription-expiry"
          echo "üîë Using secret: ${CRON_SECRET_KEY:0:20}..."
          
          RESPONSE=$(curl -s -w "HTTP_STATUS:%{http_code}" \
            -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.CRON_SECRET_KEY }}" \
            -H "User-Agent: CoinSpree-GitHub-Actions/1.0" \
            --max-time 240 \
            "${{ secrets.VERCEL_DEPLOYMENT_URL }}/api/cron/subscription-expiry")
          
          # Check if curl command succeeded
          if [ $? -ne 0 ]; then
            echo "‚ùå Curl command failed"
            exit 1
          fi
          
          # Extract HTTP status and body with better error handling
          if echo "$RESPONSE" | grep -q "HTTP_STATUS:"; then
            HTTP_STATUS=$(echo "$RESPONSE" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2)
            BODY=$(echo "$RESPONSE" | sed 's/HTTP_STATUS:[0-9]*$//')
          else
            echo "‚ùå Invalid response format: $RESPONSE"
            exit 1
          fi
          
          echo "üìä Response Status: $HTTP_STATUS"
          echo "üìã Response Body: $BODY"
          
          # Check if request was successful
          if [ "$HTTP_STATUS" -eq 200 ]; then
            echo "‚úÖ Subscription maintenance completed successfully"
            
            # Parse JSON response to extract metrics with better error handling
            EMAILS_SENT=$(echo "$BODY" | grep -o '"emailsSent":[0-9]*' | cut -d: -f2 2>/dev/null || echo "0")
            SUBSCRIPTIONS_EXPIRED=$(echo "$BODY" | grep -o '"subscriptionsExpired":[0-9]*' | cut -d: -f2 2>/dev/null || echo "0")
            DURATION=$(echo "$BODY" | grep -o '"duration":[0-9]*' | cut -d: -f2 2>/dev/null || echo "0")
            
            echo "üìß Expiry emails sent: $EMAILS_SENT"
            echo "‚è∞ Subscriptions expired: $SUBSCRIPTIONS_EXPIRED"
            echo "‚è±Ô∏è Processing time: ${DURATION}ms"
            
            # Log subscription maintenance metrics
            if [ "$EMAILS_SENT" -gt 0 ] || [ "$SUBSCRIPTIONS_EXPIRED" -gt 0 ]; then
              echo "üì¨ Subscription maintenance completed:"
              if [ "$EMAILS_SENT" -gt 0 ]; then
                echo "  - $EMAILS_SENT expiry warning emails sent to users"
              fi
              if [ "$SUBSCRIPTIONS_EXPIRED" -gt 0 ]; then
                echo "  - $SUBSCRIPTIONS_EXPIRED subscriptions marked as expired"
              fi
            else
              echo "‚ú® No subscription maintenance required - all subscriptions are current"
            fi
          else
            echo "‚ùå Subscription maintenance failed with status $HTTP_STATUS"
            echo "üîç Error details: $BODY"
            exit 1
          fi
        env:
          VERCEL_DEPLOYMENT_URL: ${{ secrets.VERCEL_DEPLOYMENT_URL }}
          CRON_SECRET_KEY: ${{ secrets.CRON_SECRET_KEY }}

  session-cleanup:
    name: Session Cleanup
    runs-on: ubuntu-latest
    timeout-minutes: 3
    needs: subscription-maintenance # Run after subscription maintenance
    
    steps:
      - name: Clean Expired Sessions
        run: |
          echo "üßπ Starting session cleanup for CoinSpree..."
          
          # Make authenticated request to session cleanup endpoint
          echo "üîó Endpoint: ${{ secrets.VERCEL_DEPLOYMENT_URL }}/api/cron/cleanup-sessions"
          echo "üîë Using secret: ${CRON_SECRET_KEY:0:20}..."
          
          RESPONSE=$(curl -s -w "HTTP_STATUS:%{http_code}" \
            -X POST \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${{ secrets.CRON_SECRET_KEY }}" \
            -H "User-Agent: CoinSpree-GitHub-Actions/1.0" \
            --max-time 120 \
            "${{ secrets.VERCEL_DEPLOYMENT_URL }}/api/cron/cleanup-sessions")
          
          # Check if curl command succeeded
          if [ $? -ne 0 ]; then
            echo "‚ùå Curl command failed"
            echo "‚ö†Ô∏è Session cleanup is non-critical, continuing..."
          else
            # Extract HTTP status and body with better error handling
            if echo "$RESPONSE" | grep -q "HTTP_STATUS:"; then
              HTTP_STATUS=$(echo "$RESPONSE" | grep -o "HTTP_STATUS:[0-9]*" | cut -d: -f2)
              BODY=$(echo "$RESPONSE" | sed 's/HTTP_STATUS:[0-9]*$//')
            else
              echo "‚ùå Invalid response format: $RESPONSE"
              HTTP_STATUS="0"
              BODY=""
            fi
            
            echo "üìä Session Cleanup Status: $HTTP_STATUS"
          
          # Check if request was successful
          if [ "$HTTP_STATUS" -eq 200 ]; then
            echo "‚úÖ Session cleanup completed successfully"
            
            # Parse JSON response if available
            CLEANED=$(echo "$BODY" | grep -o '"cleaned":[0-9]*' | cut -d: -f2 2>/dev/null || echo "unknown")
            
            if [ "$CLEANED" != "unknown" ]; then
              echo "üßπ Expired sessions cleaned: $CLEANED"
            fi
          else
            echo "‚ö†Ô∏è Session cleanup returned status $HTTP_STATUS (non-critical)"
            echo "üìã Response: $BODY"
          fi
          fi
        env:
          VERCEL_DEPLOYMENT_URL: ${{ secrets.VERCEL_DEPLOYMENT_URL }}
          CRON_SECRET_KEY: ${{ secrets.CRON_SECRET_KEY }}